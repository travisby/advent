package program

import "io"

// Scanner is a program with its iterator
type Scanner interface {
	// Err returns the first non-HALT error that was encountered by the Scanner.
	Err() error
	// Scan advances the Scanner to the next Instruction, which will then be
	// available through the Instruction method. It returns false when the
	// scan stops, either by reaching a halt or an error.
	// After Scan returns false, the Err method will return any error that
	// occurred during scanning, except that if it was HALT, Err
	// will return nil.
	Scan() bool
	// Instruction returns the most recent intcode generated by a call to Scan
	Instruction() Instruction
}

type scanner struct {
	error
	memory             []int
	instructionPointer int
	token              Instruction
	in                 io.Reader
	out                io.Writer
}

// NewScanner creates a new Program scanner from a memory block
func NewScanner(memory []int, in io.Reader, out io.Writer) Scanner {
	return &scanner{memory: memory, in: in, out: out}
}

func (s *scanner) Err() error {
	if s.error == HALT {
		return nil
	}

	return s.error
}

func (s *scanner) Scan() bool {
	if s.error != nil {
		return false
	}

	// TODO not my favorite way to add in/out
	// maybe we can come up with a better api later
	s.token, s.error = newInstruction(s.memory[s.instructionPointer:], s.in, s.out)

	// advance the program counter
	if s.error == nil {
		s.instructionPointer += s.token.numParameters() + 1
	}

	return s.error == nil
}

func (s *scanner) Instruction() Instruction {
	if s.Err() != nil {
		return nil
	}

	return s.token
}
