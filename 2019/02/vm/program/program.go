package program

// Scanner is a program with its iterator
type Scanner interface {
	// Err returns the first non-HALT error that was encountered by the Scanner.
	Err() error
	// Scan advances the Scanner to the next Intcode, which will then be
	// available through the Intcode method. It returns false when the
	// scan stops, either by reaching a halt or an error.
	// After Scan returns false, the Err method will return any error that
	// occurred during scanning, except that if it was HALT, Err
	// will return nil.
	Scan() bool
	// Intcode returns the most recent intcode generated by a call to Scan
	Intcode() Intcode
}

type scanner struct {
	error
	memory []int
	pc     int
	token  Intcode
}

// NewScanner creates a new Program scanner from a memory block
func NewScanner(memory []int) Scanner {
	return &scanner{memory: memory}
}

func (s *scanner) Err() error {
	if s.error == HALT {
		return nil
	}

	return s.error
}

func (s *scanner) Scan() bool {
	if s.error != nil {
		return false
	}

	s.token, s.error = newIntcode(s.memory[s.pc], s.memory[s.pc+1], s.memory[s.pc+2], s.memory[s.pc+3])

	// advance the program counter
	s.pc += 4 // each intcode is 4 bytes

	// TODO I think this is backwards
	return s.error == nil
}

func (s *scanner) Intcode() Intcode {
	if s.Err() != nil {
		return nil
	}

	return s.token
}
